---
title: "SesameOp: анализ бэкдора, использующего OpenAI Assistants API в качестве C2"
date: 2025-11-07
draft: false
description: "SesameOp: анализ бэкдора, использующего OpenAI Assistants API в качестве C2"
image: "/cdn/blog-cdn/large_sesameop_backdoor_openai_assistants_api_access_1024x597_148dfc124c.jpg"
---

# Введение

Исследователи из Microsoft DART обнаружили изящно скрывающуюся угрозу — бэкдор SesameOp, который превратил легитимный OpenAI Assistants API в невидимые нити для своего управления. Этот зловредный код, затаившийся в потоке законного общения с облачным сервисом, нашёл способ обмануть бдительность систем, пряча свои команды в доверенном трафике, уходящем к авторизованным доменам, — словно призрачный шепот в шуме большого города. Это история о том, как границы между доверенным и враждебным стираются, требуя новой мудрости в защите цифровых рубежей.

---

## Обнаружение и контекст инцидента

В июле 2025 года специалисты Microsoft DART реагировали на инцидент, связанный с длительным присутствием злоумышленников во внутренней инфраструктуре крупной организации. На момент начала расследования атакующие находились в среде уже **несколько месяцев**, поддерживая устойчивую связь и контролируя систему без обнаружения.

Анализ показал наличие **комплексной сети внутренних веб-шеллов**, использовавшихся для исполнения команд и обмена данными между скомпрометированными узлами. Эти веб-шеллы получали команды от **постоянных фоновых процессов**, которые были замаскированы под легитимные инструменты Microsoft Visual Studio, но фактически содержали вредоносные библиотеки.

### Механизм внедрения

Злоумышленники использовали технику **.NET AppDomainManager injection** — метод, при котором вредоносная библиотека загружается в контекст процесса .NET приложения. Это позволило внедрить код в доверенные процессы Visual Studio, тем самым обойдя многие уровни защиты.

Поиск других утилит Visual Studio, загружающих нетипичные библиотеки, привёл к обнаружению дополнительных файлов, участвующих во внешней коммуникации. Один из них содержал признаки активности OpenAI API.

Именно этот артефакт оказался **SesameOp** — тщательно разработанным бэкдором, цель которого — поддерживать длительное присутствие (long-term persistence) и предоставлять злоумышленнику удалённый контроль.

---

## Сотрудничество Microsoft и OpenAI

После подтверждения факта использования OpenAI Assistants API в качестве канала управления Microsoft передала результаты анализа в компанию OpenAI. Совместное расследование позволило:

- выявить **API-ключ** и **аккаунт**, использовавшиеся злоумышленником;
- **отключить** эти учетные данные;
- подтвердить, что аккаунт не выполнял запросов к моделям OpenAI и не взаимодействовал с сервисом за пределами нескольких ограниченных API-вызовов.

Эта деятельность не указывает на уязвимость в OpenAI или Microsoft, а лишь демонстрирует злоупотребление уже существующими возможностями легитимного API.

---

## Технический анализ SesameOp

### Архитектура заражения

Цепочка заражения SesameOp включает два основных компонента:

1. **Загрузчик (loader)** — файл `Netapi64.dll`.
2. **Основной .NET-бэкдор** — `OpenAIAgent.Netapi64`.

Оба компонента разработаны на .NET и **обфусцированы с помощью Eazfuscator.NET**, что значительно усложняет анализ.

#### Netapi64.dll – загрузчик

Файл `Netapi64.dll` выполняет начальные операции:

- создаёт маркерный файл `C:\Windows\Temp\Netapi64.start`;
- устанавливает **mutex**, предотвращающий запуск нескольких копий;
- при ошибках записывает отчёт `C:\Windows\Temp\Netapi64.Exception`;
- перечисляет файлы в каталоге `C:\Windows\Temp\` в поисках объектов с расширением `.Netapi64`;
- найденный файл XOR-декодируется и выполняется как исполняемый код.

Такой подход позволяет скрыто доставлять и активировать следующий этап — основной модуль бэкдора.

#### OpenAIAgent.Netapi64 – основной модуль

Этот компонент обеспечивает функциональность управления. Несмотря на название, он **не использует SDK OpenAI** и не вызывает модели. Вместо этого он обращается к API OpenAI Assistants, запрашивая и отправляя данные, — именно это превращает API в скрытый канал связи.

---

## Механизм работы бэкдора

### 1. Инициализация

После запуска `OpenAIAgent.Netapi64`:

- создаёт **mutex** `OpenAI APIS`;
- извлекает конфигурацию из ресурса `.NET`-секции `TextFile1`, содержащей строку:
    `<OpenAI_API_Key>|<Dictionary_Key_Name>|<Proxy>`

    где:
  - `OpenAIAgent.token` — ключ доступа к API;
  - `OpenAIAgent.aaazzz` — ключ словаря, использующийся для дешифровки;
  - `OpenAIAgent.proxy` — адрес прокси-сервера (опционален).

Если прокси указан, модуль применяет его для сетевого взаимодействия. При его отсутствии используется системная настройка по умолчанию.

Затем модуль получает имя хоста, кодирует его в Base64 и, если оно недоступно, использует строку **NAMEXXX** как замену.

---

### 2. Получение списка Vector Store из OpenAI

Первое сетевое действие — запрос списка «векторных хранилищ» (Vector Stores) через OpenAI Assistants API.

- Если в списке нет хранилища с именем текущего хоста, бэкдор создаёт новое, используя Base64-кодированное имя машины.
- Эта операция помогает уникально идентифицировать каждый заражённый узел.

---

### 3. Работа с Assistants API

Следующим шагом модуль запрашивает список всех созданных **Assistants** (до 100 шт. на одну страницу).

Из ответа сохраняются поля:

- Assistant ID,
- Name,
- Description,
- Instructions.

Именно поля `Description` и `Instructions` используются злоумышленниками для передачи команд и параметров.

Возможные значения `Description`:

1. **SLEEP** — задание паузы;
2. **Payload** — команда для выполнения;
3. **Result** — обратная передача результатов выполнения.

---

### 4. Обработка состояния SLEEP

Если `Description` = SLEEP:

- модуль считывает строку из поля `Instructions`, разделяет её по шаблону `[._.]`,
 получая **Thread ID** и **Message ID**;
- затем выполняет запрос на получение сообщения по этим ID;
- в ответе содержится поле `timeSLEEP`, которое определяет длительность ожидания;
- модуль вызывает `Thread.Sleep()` на указанное время.

Так злоумышленники могут контролировать частоту активности бэкдора и уменьшать сетевой след.

---

### 5. Обработка состояния Payload

Если `Description` = Payload:

- модуль получает сообщение (по Thread ID и Message ID);
- удаляет сообщение и соответствующего ассистента из учётной записи;
- сообщение состоит из двух частей, разделённых пробелом:
    1. **AES-ключ** (32 байта, Base64-кодировка, затем RSA-дешифровка);
    2. **Полезная нагрузка**, Base64-декодированная, расшифрованная с использованием AES-ключа, затем распакованная через GZIP.
- результат преобразуется в словарь:
  - строки разделяются символом `&`;
  - каждая пара делится по знаку `=` (макс. 2 части);
  - выполняется URL-декодирование ключей и значений.

Далее словарь передаётся в метод `executeWithJScriptEngine` вместе с ключом из конфигурации.

Метод проверяет, присутствует ли в `ApplicationState` элемент `MicroWxx`:

- если нет — извлекает, декодирует и загружает встроенный модуль (.NET) через Reflection,
    вызывает его метод `Frameworks`;
- если элемент уже существует — использует его напрямую.

Метод `Frameworks` запускает **Microsoft JScript VsaEngine**, формирует коллекцию `NameValueCollection` из словаря и выполняет найденное значение через `Eval.JScriptEvaluate`. Таким образом исполняется переданный вредоносный код.

---

### 6. Обратная отправка результатов (Result)

После выполнения задачи:

1. создаётся новый 32-байтный AES-ключ;
2. результат сжимается (GZIP), шифруется AES-ключом и кодируется Base64;
3. AES-ключ шифруется с помощью встроенного RSA-публичного ключа и также кодируется Base64;
4. оба значения соединяются пробелом;
5. объединённая строка отправляется обратно в OpenAI API как новое сообщение.

После этого модуль создаёт нового ассистента:

- имя — Base64-кодированное имя хоста;
- поле `Instruction` — объединённые Thread ID и Message ID (`[._.]`);
- поле `Description` — `Result`.

Это уведомление сигнализирует злоумышленнику, что выполнение команды завершено и результат готов.

Заключительным шагом выполняется POST-запрос в Vector Store с актуальным ID.

---

## Методы сокрытия и защита

SesameOp демонстрирует высокий уровень обфускации и гибкости. Среди применённых приёмов:

- **Eazfuscator.NET** — скрывает структуру классов и методов;
- **динамическая загрузка** модулей через Reflection;
- **использование JScript внутри .NET**, что усложняет сигнатурное обнаружение;
- **инъекция через AppDomainManager** для внедрения в доверенные процессы Visual Studio;
- **многоуровневая криптография** — RSA + AES + Base64 + GZIP;
- **взаимодействие с легитимным API** вместо собственных C2-серверов.

Такое сочетание делает угрозу практически невидимой для традиционного антивирусного анализа и сетевого мониторинга.

---

## Цель и характер атаки

Основной целью атаки являлось **долговременное присутствие** в инфраструктуре жертвы с возможностью удалённого выполнения команд, сбора данных и их скрытой отправки.

Тип угрозы классифицируется как **шпионская кампания (espionage)** — не направленная на разрушение, а на сбор разведданных и контроль инфраструктуры.

---

## Рекомендации по защите

### Краткие собранные меры защиты

**1. Аудит инфраструктуры**

- Регулярно анализировать журналы веб-серверов и сетевых шлюзов.
- Блокировать нежелательные соединения (включая `api.openai.com`, если не используется по назначению).
- Ограничить использование нестандартных портов и прокси — неавторизованные подключения блокировать.

**2. Мониторинг и поиск угроз**

- Использовать запрос в Microsoft Defender XDR для выявления устройств, обращающихся к `api.openai.com`.
- Отслеживать процессы, частоту и объём сетевых подключений.

**3. Инструменты реагирования**

- Контролировать детекторы: `Trojan:MSIL/Sesameop.A`, `Backdoor:MSIL/Sesameop.A`.
- Реагировать на оповещения о возможных внедрениях в .NET-процессы.
- Применять **Security Copilot Promptbooks** для автоматизированных расследований и оценки влияния уязвимостей.

**4. Совместные меры Microsoft и OpenAI**

- Постоянный мониторинг попыток злоупотребления ИИ.
- Блокировка скомпрометированных ключей и проверка всех вызовов API.
- Подтверждено: обращения использовались только для передачи команд и ответов, без работы языковых моделей.
- **Assistants API** будет выведен из эксплуатации в августе 2026 года — риск повторного использования схемы снизится.

---

## Выводы и значение инцидента

Случай с SesameOp является показателем новой тенденции: злоумышленники переходят от традиционных инфраструктурных каналов C2 к **злоупотреблению легитимными облачными API-сервисами**.

Это делает их трафик практически неотличимым от обычного пользовательского.
В то же время, такие атаки ставят перед компаниями новые задачи — не только защиту от уязвимостей, но и **контроль доверенных интеграций**.

SesameOp показал высокий уровень технической подготовки:

- обфускация, шифрование, сжатие и динамическая загрузка;
- применение RSA + AES-криптографии для каждой команды;
- использование JScript-интерпретатора внутри .NET;
- полное маскирование под легитимные сетевые обращения.

Всё это делает угрозу сложной даже для опытных команд безопасности.

---

## Рекомендации Microsoft для организаций

1. **Внедрить централизованный мониторинг сетевых событий** с использованием Microsoft Defender XDR или аналогичных систем.
2. **Регулярно проводить аудит систем, подключённых к интернету**, и проверять их логи на предмет необычных исходящих соединений.
3. **Использовать режим автоматического расследования и устранения (Automated Investigation & Remediation)** в Defender for Endpoint.
4. **Активировать обнаружение нежелательных программ** и включить блокировку неизвестных библиотек в средах разработки.
5. **Обучать сотрудников безопасности** принципам Threat Hunting по легитимным API-сервисам, в том числе OpenAI.

---

## Заключение

Обнаружение бэкдора **SesameOp** стало важным событием для индустрии кибербезопасности. Оно показало, что злоумышленники уже используют современные API-платформы, включая искусственный интеллект, не для эксплуатации их возможностей, а как **скрытые каналы связи**.

Такие угрозы требуют переосмысления подходов к защите:

- мониторинг должен охватывать не только подозрительные домены, но и **известные облачные адреса**;
- системы обнаружения должны учитывать контекст и поведение, а не только сигнатуры;
- организации должны иметь процедуры реагирования на необычные интеграции.

Microsoft и OpenAI оперативно пресекли активность, отключив учётные данные злоумышленников и усилив контроль. Однако этот случай остаётся предупреждением: **инновационные технологии могут быть использованы как оружие**, если отсутствует надлежащий надзор и защита.

SesameOp — пример эволюции тактик, техник и процедур (TTPs) киберпреступников, которые продолжают искать новые пути обхода защиты, используя самые современные инструменты цифрового мира.

---

## Правила/запросы для обнаружения и охоты

### 1) Sigma (универсальные SIEM правила — логика перевода в систему SIEM)

#### Sigma: Обнаружение обращений к api.openai.com от нетипичных процессов

```plain
title: Outbound Connections to api.openai.com from Non-Browser Processes
id: 6d8b3c5e-xxxx-xxxx-xxxx-xxxxxxxxxxxx
status: experimental
description: Detect outbound HTTPS connections to api.openai.com initiated by non-browser, unexpected processes (may indicate abuse of OpenAI Assistants API as C2).
author: Microsoft DART (based on provided material)
logsource:
  product: windows
  service: network
detection:
  selection:
    Url: "*api.openai.com*"
    InitiatingProcessFileName|contains: ["devenv.exe", "msbuild.exe", "dotnet.exe", "OpenAIAgent.Netapi64", "Netapi64.dll"]
  condition: selection
falsepositives:
```

- Legitimate integrations with OpenAI from developer machines or CI/CD systems. Tune by whitelisting known hosts/processes.
level: high

#### Sigma: Поиск файлов в Temp с префиксом Netapi64

```plain
title: File Creation in Temp Matching Netapi64 Indicators
id: 9a4f2b3e-xxxx-xxxx-xxxx-xxxxxxxxxxxx
status: experimental
description: Detect creation of files named Netapi64.start or files with .Netapi64 in Windows Temp folder.
author: Microsoft DART (based on provided material)
logsource:
  product: windows
  service: file
detection:
  selection:
    TargetFilename|endswith:
      - "\\Windows\\Temp\\Netapi64.start"
    TargetFilename|contains: "\\Windows\\Temp\\" and TargetFilename|contains: "Netapi64"
  condition: selection
falsepositives:

- Developers creating temporary artifacts with similar names (unlikely). Verify source process.
level: high
```

---

### 2) YARA (статический поиск на диске / образах)

> YARA-правило ориентировано на обнаружение строк/маркеров, упомянутых в анализе. Оно полезно при сканировании файловых систем/образов.

```plain
rule SesameOp_indicators
{
    meta:
        description = "Detect potential SesameOp artifacts by strings from analysis"
        author = "Microsoft DART derived"
        date = "2025-07"
        reference = "Based on provided DART technical writeup"
    strings:
        $s1 = "Netapi64.start" ascii
        $s2 = "Netapi64.Exception" ascii
        $s3 = "OpenAI APIS" ascii
        $s4 = "OpenAIAgent.aaazzz" ascii
        $s5 = "TextFile1" ascii
        $s6 = "OpenAIAgent.token" ascii
        $s7 = "MicroWxx" ascii
        $s8 = "NAMEXXX" ascii
    condition:
        (any of ($s*)) and filesize < 50MB
}
```

_Примечание:_ YARA-правило ищет явные маркеры и полезно для первичного обнаружения; обфусцированный код может не содержать читаемых строк — в таком случае аналитика по поведению важнее.

---

### 3) Snort/Suricata (IDS) — пример сетевого правила для обнаружения исходящих запросов к api.openai.com

**Snort/Suricata (пример для HTTP Host SNI detection):**

```plain
alert http any any -> any any (msg:"Potential SesameOp - HTTP Host contains api.openai.com"; flow:to_server,established; http.host; content:"api.openai.com"; nocase; sid:1000001; rev:1;)
```

_Примечание:_ При использовании TLS с SNI можно искать `tls SNI` вместо `http.host`. Если трафик проходит через корпоративный HTTPS-прокси, анализируйте прокси-логи на совпадение с `api.openai.com`.

## Вывод

SesameOp представляет собой новый тип сложного бэкдора, разработанный для скрытого и устойчивого присутствия в системах жертвы. Его уникальность заключается в использовании **OpenAI Assistants API** как канала управления и связи (C2), что позволяет злоумышленникам обходить традиционные механизмы обнаружения и не строить собственную инфраструктуру командных серверов.

Атака опирается на **.NET AppDomainManager injection**, загрузчик **Netapi64.dll** и зашифрованный компонент **OpenAIAgent.Netapi64**, который взаимодействует с OpenAI API, шифруя и сжимая все команды и результаты.

Основная цель — **долгосрочный кибершпионаж** с минимальными признаками присутствия.
Несмотря на отсутствие уязвимостей в OpenAI, инцидент демонстрирует, как легитимные сервисы ИИ могут **злоупотребляться для скрытых коммуникаций**.

Совместное расследование Microsoft и OpenAI позволило **деактивировать скомпрометированный API-ключ**, ограничить инфраструктуру злоумышленников и выработать обновлённые методы детектирования.
Главный урок — современные угрозы адаптируются к новым технологиям, и защита должна включать мониторинг не только подозрительных IP или файлов, но и **поведенческих признаков** использования законных облачных API в нетипичном контексте.
